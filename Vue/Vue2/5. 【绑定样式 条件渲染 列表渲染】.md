# 05 【绑定样式 条件渲染 列表渲染】

## 1.绑定样式

### 1.1class样式

写法：:class="xxx" xxx可以是字符串、对象、数。

所以分为三种写法，字符串写法，数组写法，对象写法

#### 字符串写法

字符串写法适用于：类名不确定，要动态获取。

```html
<style>
	.normal{
        background-color: skyblue;
    }
</style>

<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
    <div class="basic" :class="mood" @click="changeMood">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            mood:'normal'
        }
    })
</script>
```

#### 数组写法

数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。

```html
<style>
    .atguigu1{
        background-color: yellowgreen;
    }
    .atguigu2{
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    }
    .atguigu3{
        border-radius: 20px;
    }
</style>

<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
	<div class="basic" :class="classArr">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            classArr: ['atguigu1','atguigu2','atguigu3']
       }
    })
</script>
```

#### 对象写法

对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。

```html
<style>
    .atguigu1{
        background-color: yellowgreen;
    }
    .atguigu2{
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    }
</style>

<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->
	<div class="basic" :class="classObj">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            classObj:{
                atguigu1:false,
                atguigu2:false,
			}
        }
    })
</script>
```

### 1.2style样式

有两种写法，对象写法，数组写法

#### 对象写法

```html
<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定style样式--对象写法 -->
	<div class="basic" :style="styleObj">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            styleObj:{
                fontSize: '40px',
                color:'red',
			}
        }
    })
</script>
```

#### 数组写法

```html
<!-- 准备好一个容器-->
<div id="root">
    <!-- 绑定style样式--数组写法 -->
	<div class="basic" :style="styleArr">{{name}}</div>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            styleArr:[
                {
                    fontSize: '40px',
                    color:'blue',
                },
                {
                    backgroundColor:'gray'
                }
            ]
        }
    })
</script>
```

## 2.条件渲染

```
条件渲染:
	1.v-if
    	写法:
			(1).v-if="表达式"
			(2).v-else-if="表达式"
			(3).v-else="表达式"
		适用于: 切换频率较低的场景
        特点: 不展示的Dom元素直接被移除
        注意: v-if可以和v-else-if、v-else一起使用，但要求结构不能被"打断"
	2.v-show
		写法: v-show="表达式"
		适用于: 切换频率较高的场景
        特点: 不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
    3.备注: 使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到
```

### 2.1v-if

- 写法：

  (1).`v-if`="表达式"

  (2).`v-else-if`="表达式"

  (3).`v-else`="表达式"

- 适用于：切换频率较低的场景，因为不展示的`DOM`元素直接被移除

- 特点：不展示的DOM元素直接被移除

- 注意：`v-if`可以和`v-else-if`、`v-else`一起使用，但要求结构不能被“打断”

- `template`标签不影响结构，页面html中不会有此标签，但只能配合v-if，不能配合v-show

```html
<!-- 准备好一个容器-->
<div id="root">
    <!-- 使用v-if做条件渲染 -->
    <h2 v-if="false">欢迎来到{{name}}</h2>
    <h2 v-if="1 === 1">欢迎来到{{name}}</h2>
    
    
    <!-- v-else和v-else-if -->
    <div v-if="n === 1">Angular</div>
    <div v-else-if="n === 2">React</div>
    <div v-else-if="n === 3">Vue</div>
    <div v-else>哈哈</div>
    
    
    <!-- v-if与template的配合使用 -->
    <!-- 就不需要写好多个判断，写一个就行 -->
    <!-- 这里的思想就像事件代理的使用 -->
    <template v-if="n === 1">
        <h2>你好</h2>
        <h2>尚硅谷</h2>
        <h2>北京</h2>
    </template>
</div>

<script>
	const vm = new Vue({
        el:'#root',
        data:{
            styleArr:[
                {
                    fontSize: '40px',
                    color:'blue',
                },
                {
                    backgroundColor:'gray'
                }
            ]
        }
    })
</script>
```

### 2.2v-show

- 写法：v-show="表达式"
- 适用于：切换频率较高的场景
- 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉(display:none)
- 备注：使用`v-if`的时，元素可能无法获取到，而使用`v-show`一定可以获取到 v-if 是实打实地改变`dom`元素，v-show 是隐藏或显示`dom`元素

```html
<!-- 准备好一个容器-->
<div id="root">
    <!-- 使用v-show做条件渲染 -->
    <h2 v-show="false">欢迎来到{{name}}</h2>
    <h2 v-show="1 === 1">欢迎来到{{name}}</h2>
</div>
```

## 3.列表渲染

```p
v-for指令:
	1.用于展示列表数据
    2.语法: v-for="(item,index) in xxx" :key="yyy"
	3.可遍历: 数组、对象、字符串(用的很少)、指定次数(用的很少)
	注意:在v-for中in与of在使用中没有区别，都可以遍历数组和对象，在遍历数组时，key与index的值相同，一般会略去key只写（item，index）;
```

### 3.1v-for指令

- 用于展示列表数据
- 语法：`v-for`="**(item, index)** `in` **xxx**" `:key`=**"yyy"**，这里key可以是index，更好的是遍历对象的唯一标识 如果key写的是index，前面可以不写index也能用
- 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）

```html
<title>基本列表</title>
<script type="text/javascript" src="../js/vue.js"></script>

<div id="root">
  <!-- 遍历数组 -->
  <h3>人员列表（遍历数组）</h3>
  <ul>
    <li v-for="(p,index) of persons" :key="index">{{ p.name }}-{{ p.age }}</li>
  </ul>

  <!-- 遍历对象 -->
  <h3>汽车信息（遍历对象）</h3>
  <ul>
    <li v-for="(value,k) of car" :key="k">{{ value }}--{{ k }}</li>
  </ul>

  <!-- 遍历字符串 -->
  <h3>测试遍历字符串（用得少）</h3>
  <ul>
    <li v-for="(char,index) of str" :key="index">{{ char }}-{{ index }}</li>
  </ul>

  <!-- 遍历指定次数 -->
  <h3>测试遍历指定次数（用得少）</h3>
  <ul>
    <li v-for="(number,index) of 5" :key="index">{{ number }}--{{ index }}</li>
  </ul>
</div>

<script type="text/javascript">
  Vue.config.productionTip = false
  new Vue({
    el: '#root',
    data: {
      persons: [
        { id: '001', name: '张三', age: 18 },
        { id: '002', name: '李四', age: 19 },
        { id: '003', name: '王五', age: 20 }
      ],
      car: {
        name: '奥迪A8',
        price: '70万',
        color: '黑色'
      },
      str: 'hello'
    }
  })
</script>
```



### 3.2 key

```markdown
面试题: react、vue中的key有什么作用? (key的内部原理)
	1.虚拟DOM中key的作用:
		key是虚拟DOM对象的标识，当数据发生变化时，vue会根据[新数据]生成[新的虚拟DOM]，
        随后Vue进行[新虚拟DOM]与[旧虚拟DOM]的差异比较，比较规则如下:
	2.对比规则:
		(1).旧虚拟DOM中找到了与新虚拟DOM相同的key:
        	①.若虚拟DOM中内容没变，直接使用之前的真实DOM!
            ②.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM
		(2).旧虚拟DOM中未找到与新虚拟DOM相同的key
			创建新的真实DOM，随后渲染到页面
	3.用index作为key可能引发的问题:
		(1).若对数据进行: 逆序添加、逆序删除等破坏顺序操作:
							会产生没有必要的真实DOM更新 ===> 界面效果没问题，但效率低
		(2).如果结构中还包含输入类的DOM:
                            会产生错误DOM更新 ===> 界面有问题
	4.开发中如何选择key?
        (1).最好使用每条数据的唯一标识作为key，比如id、手机号码、身份证号、学号等唯一值
		(2).如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
			使用index作为key是没有问题的
```

![Snipaste_2022-08-24_20-56-40](https://gitee.com/river-ice/notes/raw/master/%E5%89%8D%E7%AB%AF/Vue/assets/953504ff3889a359cba85093a562a66b447bb41f.jpg)

![Snipaste_2022-08-24_20-58-43](https://gitee.com/river-ice/notes/raw/master/%E5%89%8D%E7%AB%AF/Vue/assets/4c5c7efe2b08c6a26ca81340713f6b7389436279.jpg)

### 3.3列表过滤

#### watch实现

```html
<div id="root">
  <h2>人员列表</h2>
  <input type="text" placeholder="请输入名字" v-model="keyWord">
  <ul>
    <li v-for="(p,index) of filPersons" :key="p.id">
      {{ p.name }}-{{ p.age }}-{{ p.sex }}
    </li>
  </ul>
</div>

<script type="text/javascript">
  Vue.config.productionTip = false
  // 用 watch 实现 
   new Vue({
			el: '#root',
			data: {
				keyWord: '',
				persons: [
					{ id: '001', name: '马冬梅', age: 19, sex: '女' },
					{ id: '002', name: '周冬雨', age: 20, sex: '女' },
					{ id: '003', name: '周杰伦', age: 21, sex: '男' },
					{ id: '004', name: '温兆伦', age: 22, sex: '男' }
				],
				filPersons: []
			},
			watch: {
				keyWord: {
					immediate: true,
					handler(val) {
						this.filPersons = this.persons.filter((p) => {
							return p.name.indexOf(val) !== -1
						})
					}
				}
			}
		}) 
</script>
```

> 注意:`indexOf`对于空串的结果是0，这样上面代码初始过滤就是全部数据

#### computed实现

```html
<div id="root">
  <h2>人员列表</h2>
  <input type="text" placeholder="请输入名字" v-model="keyWord">
  <ul>
    <li v-for="(p,index) of filPersons" :key="p.id">
      {{ p.name }}-{{ p.age }}-{{ p.sex }}
    </li>
  </ul>
</div>

<script type="text/javascript">
  Vue.config.productionTip = false
  // 用 computed 实现
  new Vue({
    el: '#root',
    data: {
      keyWord: '',
      persons: [
        { id: '001', name: '马冬梅', age: 19, sex: '女' },
        { id: '002', name: '周冬雨', age: 20, sex: '女' },
        { id: '003', name: '周杰伦', age: 21, sex: '男' },
        { id: '004', name: '温兆伦', age: 22, sex: '男' }
      ]
    },
    computed: {
      filPersons() {
        return this.persons.filter((p) => {
          return p.name.indexOf(this.keyWord) !== -1
        })
      }
    }
  }) 
</script>
```

### 3.4列表排序

> 有时为了减少服务器压力，能在前端做的尽量在前端做。

```html
<div id="root">
  <h2>人员列表</h2>
  <input type="text" placeholder="请输入名字" v-model="keyWord">
  <button @click="sortType = 2">年龄升序</button>
  <button @click="sortType = 1">年龄降序</button>
  <button @click="sortType = 0">原顺序</button>
  <ul>
    <li v-for="(p,index) of filPersons" :key="p.id">
      {{p.name}}-{{p.age}}-{{p.sex}}
      <input type="text">
    </li>
  </ul>
</div>

<script type="text/javascript">
  Vue.config.productionTip = false
  new Vue({
    el: '#root',
    data: {
      keyWord: '',
      sortType: 0, // 0原顺序 1降序 2升序
      persons: [
        { id: '001', name: '马冬梅', age: 30, sex: '女' },
        { id: '002', name: '周冬雨', age: 31, sex: '女' },
        { id: '003', name: '周杰伦', age: 18, sex: '男' },
        { id: '004', name: '温兆伦', age: 19, sex: '男' }
      ]
    },
    computed: {
      filPersons() {
        const arr = this.persons.filter((p) => {
          return p.name.indexOf(this.keyWord) !== -1
        })
        //判断一下是否需要排序
        if (this.sortType) {
          arr.sort((p1, p2) => {
            return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age
          })
        }
        return arr
      }
    }
  })
</script>
```

[![image-20220628125312802](https://camo.githubusercontent.com/e9791f7cc446574938d45d5f43c0850e8d1485935e7d532f56b4020ac1371180/68747470733a2f2f69302e6864736c622e636f6d2f6266732f616c62756d2f656532373333663536663563623365626465646639383534353937346236613663316330636265612e706e67)](https://camo.githubusercontent.com/e9791f7cc446574938d45d5f43c0850e8d1485935e7d532f56b4020ac1371180/68747470733a2f2f69302e6864736c622e636f6d2f6266732f616c62756d2f656532373333663536663563623365626465646639383534353937346236613663316330636265612e706e67)
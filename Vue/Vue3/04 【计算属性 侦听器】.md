# 04 【计算属性 侦听器】

## 1.计算属性

有时我们需要依赖于其他状态(普通proxy响应式数据)的状态(computed响应式数据)： 在 Vue 中，这是用组件计算属性处理的，以直接创建计算值，我们可以使用 computed 函数：它接受 getter 函数并为 getter 返回的值返回一个不可变的响应式 ref 对象。

### 1.1 computed函数

> 与Vue2.x中computed配置功能一致
>
> 可以直接去看3.7.3完整写法

模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：

```javascript
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})
```



我们想根据 `author` 是否已有一些书籍来展示不同的信息：

```javascript
<p>Has published books:</p>
<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
```



这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 `author.books`。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。

因此我们推荐使用**计算属性**来描述依赖响应式状态的复杂逻辑。这是重构后的示例：

```JavaScript
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```



[在演练场中尝试一下](https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlYWN0aXZlLCBjb21wdXRlZCB9IGZyb20gJ3Z1ZSdcblxuY29uc3QgYXV0aG9yID0gcmVhY3RpdmUoe1xuICBuYW1lOiAnSm9obiBEb2UnLFxuICBib29rczogW1xuICAgICdWdWUgMiAtIEFkdmFuY2VkIEd1aWRlJyxcbiAgICAnVnVlIDMgLSBCYXNpYyBHdWlkZScsXG4gICAgJ1Z1ZSA0IC0gVGhlIE15c3RlcnknXG4gIF1cbn0pXG5cbi8vIGEgY29tcHV0ZWQgcmVmXG5jb25zdCBwdWJsaXNoZWRCb29rc01lc3NhZ2UgPSBjb21wdXRlZCgoKSA9PiB7XG4gIHJldHVybiBhdXRob3IuYm9va3MubGVuZ3RoID4gMCA/ICdZZXMnIDogJ05vJ1xufSlcbjwvc2NyaXB0PlxuXG48dGVtcGxhdGU+XG4gIDxwPkhhcyBwdWJsaXNoZWQgYm9va3M6PC9wPlxuICA8c3Bhbj57eyBwdWJsaXNoZWRCb29rc01lc3NhZ2UgfX08L3NwYW4+XG48L3RlbXBsYXRlPiIsImltcG9ydC1tYXAuanNvbiI6IntcbiAgXCJpbXBvcnRzXCI6IHtcbiAgICBcInZ1ZVwiOiBcImh0dHBzOi8vc2ZjLnZ1ZWpzLm9yZy92dWUucnVudGltZS5lc20tYnJvd3Nlci5qc1wiXG4gIH1cbn0ifQ==)

我们在这里定义了一个计算属性 `publishedBooksMessage`。`computed()` 方法期望接收一个 getter 函数，返回值为一个**计算属性 ref**。和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。

Vue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新。

也可参考：[为计算属性标注类型](https://staging-cn.vuejs.org/guide/typescript/composition-api.html#typing-computed)

### 1.2 其它使用

> - 接受一个具有 `get` 和 `set` 函数的对象，用来创建可写的 ref 对象。
> - 该案例功能常用于父组件双向绑定，在子组件 props 与 computed结合使用很方便！
>
> ```javascript
> import { ref,computed } from 'vue';
> let test2_count = ref(0)
>  
> let test2 = computed({
>   // test2.value = 3 则会触发 set()
>   // set/get里都不能操作test2.value，否则会报错
>  
>   get: () => {
>     return test2_count.value + '可变的响应式ref对象'
>   },
>   set: (val:any) => {
>     test2_count.value = val - 11
>   }
> })
> test2.value = 1 // test2_count.value = 1 - 11
> ```

> **调试 Computed**
>
> computed 可接受一个带有 onTrack 和 onTrigger 选项的对象作为第二个参数：
>
> - onTrack 会在某个响应式 property 或 ref 作为依赖被追踪时调用。
> - onTrigger 会在侦听回调被某个依赖的修改触发时调用。
>
> 所有回调都会收到一个 debugger 事件参数，其中包含了一些依赖相关的信息。推荐在这些回调内放置一个 debugger 语句以调试依赖。
>
> ```javascript
> import { ref,computed } from 'vue';
> let count = ref(147)
> let countComputed = computed(() => count.value + '计算属性',{
>   onTrack(e) {
>     // 当 count.value 作为依赖被追踪时触发。用人话将就是被访问的时候触发
>     console.log('onTrack',e);
>   },
>   onTrigger(e) {
>     // 当 count.value 被修改时触发
>     console.log('onTrigger',e);
>   }
> })
> ```
>
> 
>
> **注意：onTrack 和 onTrigger 仅在开发模式下生效 ！！**

### 1.3 计算属性vs方法

你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：



```javascript
<p>{{ calculateBooksMessage() }}</p>
// 组件中
function calculateBooksMessage() {
  return author.books.length > 0 ? 'Yes' : 'No'
}
```

若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 getter 函数。

这也解释了为什么下面的计算属性永远不会更新，因为 `Date.now()` 并不是一个响应式依赖：



```javascript
const now = computed(() => Date.now())
```

相比之下，方法调用**总是**会在重渲染发生时再次执行函数。

为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 `list`，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 `list`。没有缓存的话，我们会重复执行非常多次 `list` 的计算函数，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。

**官网的建议**

1. **计算函数不应有副作用[#open in new window](https://staging-cn.vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free)** 计算属性的计算函数应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，**不要在计算函数中做异步请求或者更改 DOM**！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此计算函数的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用[监听器open in new window](https://staging-cn.vuejs.org/guide/essentials/watchers.html)根据其他响应式状态的变更来创建副作用。
2. **避免直接修改计算属性值[#open in new window](https://staging-cn.vuejs.org/guide/essentials/computed.html#avoid-mutating-computed-value)** 从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。

## 2.侦听器

### 2.1 基本使用

在组合式 API 中，我们可以使用 [`watch` 函数open in new window](https://staging-cn.vuejs.org/api/reactivity-core.html#watch)在每次响应式状态发生变化时触发回调函数

> 与Vue2.x中watch配置功能一致

**详细信息**

`watch()` 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。

第一个参数是侦听器的**源**。这个来源可以是以下几种：

- 一个函数，返回一个值
- 一个 ref
- 一个响应式对象
- ...或是由以上类型的值组成的数组

第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。

当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。

第三个可选的参数是一个对象，支持以下这些选项：

- **`immediate`**：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。
- **`deep`**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考[深层侦听器open in new window](https://staging-cn.vuejs.org/guide/essentials/watchers.html#deep-watchers)一节。
- **`flush`**：调整回调函数的刷新时机。参考[回调的刷新时机open in new window](https://staging-cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing)一节。
- **`onTrack / onTrigger`**：调试侦听器的依赖。参考[调试侦听器open in new window](https://staging-cn.vuejs.org/guide/extras/reactivity-in-depth.html#watcher-debugging)一节。

> **缓冲回调**：缓冲回调不仅可以提高性能，还有助于保证数据的一致性。在执行数据更新的代码完成之前，侦听器不会被触发。简单来说，同步修改数据时，修完操作执行完毕后才会触发回调。注意是同步！所以异步操作的时候，要注意多次触发watch的问题。（所有同步操作为1次，异步操作有几次就触发多少次监听！！）

`watch` 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组
# 【Express基本使用】

> [https://www.expressjs.com.cn/](https://gitee.com/link?target=https%3A%2F%2Fwww.expressjs.com.cn%2F)

基于 Node.js 平台，快速、开放、极简的 web 开发框架。

## 1.Express的安装方式

Express的安装可直接使用npm包管理器上的项目，在安装npm之前可先安装淘宝镜像：

```
npm install -g cnpm --registry=https://registry.npmmirror.com/
```

这样我们使用cnpm的来代替npm，这使得下载速度提高很多；其次你需要在你项目目录下运行以下指令来初始化npm，期间所有提示按enter键即可，这会生成package.json，它是用于描述项目文件的。

```shell
cnpm init
```

再输入

```
cnpm install
```

这下项目目录中又会多出一个叫node_modules文件夹，里面是node.js为我们提供的模块，当然现在没有。接下来便是真正的安装express了，执行：

```
cnpm install express --save
```

这时，我们看到node_modules文件夹多了许多不同版本的应用文件夹，接下来执行

```
express --version
```

查看express是否安装成功，如果显示版本号，则安装正确。

![image-20221103194431096](https://gitee.com/river-ice/notes/raw/master/%E5%89%8D%E7%AB%AF/nodejs/%E5%A4%A7%E4%BD%AC/assets/62c7b3ce419bd390b082314ccb8233e5b2cafa65.png)

## 2.运行原理

### **底层：http模块**

> Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下

```JavaScript
var http = require("http");

var app = http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.end("Hello world!");
});

app.listen(3000, "localhost");
```

> Express框架的核心是对http模块的再包装。上面的代码用Express改写如下

```JavaScript
var express = require('express');
var app = express();

app.get('/', function (req, res) {
  res.send('Hello world!');
});

app.listen(3000);
```

> Express框架等于在http模块之上，加了一个中间层

### **什么是中间件**

> - 简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件
> - 每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。

- 一个不进行任何操作、只传递`request`对象的中间件，就是下面这样

```JavaScript
function uselessMiddleware(req, res, next) {
  next();
}
```

- 上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本
- 抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止

```JavaScript
function uselessMiddleware(req, res, next) {
  next('出错了！');
}
```

## 3.Express 方法

### **Express路由简介**

路由表示应用程序端点 (URI) 的定义以及响应客户端请求的方式。它包含一个请求方时（methods）、路径（path）和路由匹配时的函数（callback）;

```JavaScript
app.methods(path, callback);
```

### **Express路由方法**

Express方法源于 HTTP 方法之一，附加到 express 类的实例。它可请求的方法包括：

get、post、put、head、delete、options、trace、copy、lock、mkcol、move、purge、propfind、proppatch、unlock、report、mkactivity、checkout、merge、m-search、notify、subscribe、unsubscribe、patch、search 和 connect。

> 路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。
>
> 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path,  [callback...], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法，  path 是服务器上的路径， callback 是当路由匹配时要执行的函数。

下面是一个基本的路由示例：

```JavaScript
var express = require('express');
var app = express();

// respond with "hello world" when a GET request is made to the homepage
app.get('/', function(req, res) {
  //写完一个send，后面所有跟路由有关的都不会执行
  //会自动响应对应的数据类型
  //   res.send([1, 2, 3]);
  //   res.send({ ok: 1 });
  //   res.json({ ok: 1 });
   // 使用混合使用函数数组处理时如果前面有res.send();那么后面和路由处理相关代码都不生效
  res.send('hello world');
  res.send(`
        <html>
            <h1>hello world</h2>
        </html>
    `);
});
```

路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。

### **all方法和HTTP动词方法**

> 针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写

```JavaScript
var express = require("express");
var http = require("http");
var app = express();

app.all("*", function(request, response, next) {
  response.writeHead(200, { "Content-Type": "text/plain" });
  next();
});

app.get("/", function(request, response) {
  response.end("Welcome to the homepage!");
});

app.get("/about", function(request, response) {
  response.end("Welcome to the about page!");
});

app.get("*", function(request, response) {
  response.end("404!");
});

http.createServer(app).listen(1337);
```

> - 上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了
> - 除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法

- 除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法
- 这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配

```JavaScript
app.get("/hello/:who", function(req, res) {
  res.end("Hello, " + req.params.who + ".");
});
```

## 4.路径匹配

### 4.1 字符串路径

```JavaScript
// 匹配根路径的请求
app.get('/', function (req, res) {
  res.send('root');
});

// 匹配 /about 路径的请求
app.get('/about', function (req, res) {
  res.send('about');
});

// 匹配 /random.text 路径的请求
app.get('/random.text', function (req, res) {
  res.send('random.text');
});
```

### 4.2 字符串模式路径

使用字符串模式的路由路径示例：

```JavaScript
// 匹配 acd 和 abcd
app.get('/ab?cd', function(req, res) {
  res.send('ab?cd');
});

// 匹配 abcd、abbcd、abbbcd等
app.get('/ab+cd', function(req, res) {
  res.send('ab+cd');
});

// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等
app.get('/ab*cd', function(req, res) {
  res.send('ab*cd');
});

// 匹配 /abe 和 /abcde
app.get('/ab(cd)?e', function(req, res) {
 res.send('ab(cd)?e');
});
```

### 4.3 正则表达式路径

使用正则表达式的路由路径示例：

```JavaScript
// 匹配任何路径中含有 a 的路径：
app.get(/a/, function(req, res) {
  res.send('/a/');
});

// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等
app.get(/.*fly$/, function(req, res) {
  res.send('/.*fly$/');
});
```

可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next('route') 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。

```JavaScript
app.get('/example/a', function (req, res) {
  res.send('Hello from A!');
});
```

使用多个回调函数处理路由（记得指定 next 对象）：

```JavaScript
app.get('/example/b', function (req, res, next) {
  console.log('response will be sent by the next function ...');
  next();
}, function (req, res) {
  res.send('Hello from B!');
});
```

使用回调函数数组处理路由：

```JavaScript
var cb0 = function (req, res, next) {
  console.log('CB0')
  next()
}

var cb1 = function (req, res, next) {
  console.log('CB1')
  next()
}

var cb2 = function (req, res) {
  res.send('Hello from C!')
}

app.get('/example/c', [cb0, cb1, cb2])
```

## 5.response对象

| 方法                                                         | 描述                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------ |
| [res.download()](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.download) | 提示要下载的文件。                                     |
| [res.end（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.end) | 结束响应过程。                                         |
| [res.json（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.json) | 发送JSON响应。                                         |
| [res.jsonp（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.jsonp) | 发送带有JSONP支持的JSON响应。                          |
| [res.redirect（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.redirect) | 重定向请求。                                           |
| [res.render（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.render) | 渲染视图模板。                                         |
| [res.send（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.send) | 发送各种类型的响应。                                   |
| [res.sendFile（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.sendFile) | 将文件作为八位字节流发送。                             |
| [res.sendStatus（）](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23res.sendStatus) | 设置响应状态代码，并将其字符串表示形式发送为响应正文。 |

例：

**（1）response.redirect方法**

> response.redirect方法允许网址的重定向

```JavaScript
response.redirect("/hello/anime");
response.redirect("http://www.example.com");
response.redirect(301, "http://www.example.com"); 
```

**（2）response.sendFile方法**

> response.sendFile方法用于发送文件

```
response.sendFile("/path/to/anime.mp4");
```

**（3）response.render方法**

> response.render方法用于渲染网页模板。

```
//  使用render方法，将message变量传入index模板，渲染成HTML网页
app.get("/", function(request, response) {
  response.render("index", { message: "Hello World" });
});
```

在express框架中，res对象代表服务器响应的对象，包含了许多常用的属性和方法。

**1. res.send()**

用于向客户端发送数据，可以是字符串、JSON对象、Buffer对象等。res.send()方法会自动设置Content-Type和Content-Length头部信息。

```JavaScript
javascript
app.get('/', (req, res) => {
  res.send('Hello World!');
});
```

**2. res.json()**

用于向客户端发送JSON数据，自动设置Content-Type为application/json。

```JavaScript
javascript
app.get('/user', (req, res) => {
  const user = { id: 1, name: '张三', age: 18 };
  res.json(user);
});
```

**3. res.sendFile()**

用于向客户端发送文件，可以是绝对路径或相对路径。需要注意的是，必须指定文件的绝对路径或相对路径，否则无法找到文件。

```JavaScript
javascript
app.get('/download', (req, res) => {
  const filePath = path.join(__dirname, 'public', 'file.txt');
  res.sendFile(filePath);
});
```

**4. res.status()**

用于设置HTTP状态码，默认状态码为200。使用res.status()方法可以将状态码设置为其他值，比如404、500等。

```JavaScript
javascript
app.get('/not-found', (req, res) => {
  res.status(404).send('Not Found');
});
```

**5. res.setHeader()**

用于设置响应头信息，可以设置Content-Type、Content-Length、Cache-Control等头部信息。

```JavaScript
javascript
app.get('/cache', (req, res) => {
  res.setHeader('Cache-Control', 'max-age=3600');
  res.send('Hello World!');
});
```

**6. res.cookie()**

用于添加cookie，第一个参数表示cookie的名称，第二个参数表示cookie的值。可以设置cookie的过期时间、域名、路径等属性。

```JavaScript
javascript
app.get('/set-cookie', (req, res) => {
  res.cookie('username', 'zhangsan', { maxAge: 60 * 1000 });
  res.send('Set Cookie');
});
```

**7. res.clearCookie()**

用于清除指定名称的cookie。

```JavaScript
javascript
app.get('/clear-cookie', (req, res) => {
  res.clearCookie('username');
  res.send('Clear Cookie');
});
```

还有其他一些常用的res对象属性和方法，如redirect、download等，具体可以参考官方文档。

## 7.中间件

Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。

中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。

中间件的功能包括：

- 执行任何代码。
- 修改请求和响应对象。
- 终结请求-响应循环。
- 调用堆栈中的下一个中间件。

**如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。**

Express 应用可使用如下几种中间件：

- 应用级中间件
- 路由级中间件
- 错误处理中间件
- 内置中间件
- 第三方中间件

**使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。**

### 7.1 应用级中间件

应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：

```JavaScript
var app = express()
const indexRouter = require('./route/indexRouter');
const LoginRouter = require('./route/LoginRouter');

//应用级别(后面的路由都会执行此中间件)
app.use((req, res, next) => {
  // 验证用户token过期, cookie过期
  console.log('token验证');
  let isValid = true;
  if (isValid) {
    next();
  } else {
    res.send('error');
  }
});

//应用级别(这里不写路径默认/)
//这些use方法是每次访问都是从上往下执行
//如果是/login/a,会先找到/login开头的这个应用级中间件
//然后再进入这个中间件找/a
app.use(indexRouter);
app.use('/login', LoginRouter);
```

### 7.2 路由级中间件

#### 7.2.1 app.route()

您可以使用来为路由路径创建可链接的路由处理程序`app.route()`。由于路径是在单个位置指定的，因此创建模块化路由非常有帮助，减少冗余和错别字也很有帮助。有关路由的更多信息，请参见：[Router（）文档](https://gitee.com/link?target=http%3A%2F%2Fwww.expressjs.com.cn%2Fen%2F4x%2Fapi.html%23router)。

这是使用定义的链式路由处理程序的示例`app.route()`。

```JavaScript
app.route('/book')
  .get(function (req, res) {
    res.send(' Get a random book')
  })
  .post(function (req, res) {
    res.send('Add a book')
  })
  .put(function (req, res) {
    res.send('Update the book')
  })
```

#### 7.2.2 快速路由器

路由级中间件和应用级中间件一样，只是它绑定的对象为 `express.Router()`。

使用`express.Router`该类创建模块化的，可安装的路由处理程序。一个`Router`实例是一个完整的中间件和路由系统; 因此，它通常被称为“迷你应用程序”。

以下示例将路由器创建为模块，在其中加载中间件功能，定义一些路由，并将路由器模块安装在主应用程序的路径上。

`home.js`在app目录中创建一个名为以下内容的路由器文件：

```JavaScript
var router = express.Router()
var app = express()
var router = express.Router()

// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件
router.use(function (req, res, next) {
  console.log('Time:', Date.now())
  next()
})

// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息
router.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}, function (req, res, next) {
  console.log('Request Type:', req.method)
  next()
})

// 一个中间件栈，处理指向 /user/:id 的 GET 请求
router.get('/user/:id', function (req, res, next) {
  // 如果 user id 为 0, 跳到下一个路由
  if (req.params.id == 0) next('route')
  // 负责将控制权交给栈中下一个中间件
  else next() //
}, function (req, res, next) {
  // 渲染常规页面
  res.render('regular')
})

// 处理 /user/:id， 渲染一个特殊页面
router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id)
  res.render('special')
})

module.exports=  router
```

然后，在应用程序中加载路由器模块：

```JavaScript
var indexRouter = require('./home')
// ...
app.use('/home', index)
```

该应用程序现在将能够处理对`/home`和的请求`/home/user/123456`

#### 7.2.3 router.route方法

> router实例对象的route方法，可以接受访问路径作为参数

```JavaScript
var router = express.Router();

router.route('/api')
	.post(function(req, res) {
		// ...
	})
	.get(function(req, res) {
		Bear.find(function(err, bears) {
			if (err) res.send(err);
			res.json(bears);
		});
	});

module.exports=  router
```

### 7.3 错误处理中间件

错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。

```JavaScript
//上面的中间件都没有匹配就会走这里
app.use(function(err, req, res, next) {
  console.error(err.stack)
     //send的状态码默认是200
  res.status(500).send('error')
})
```

### 7.4 内置的中间件

express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。每个应用可有多个静态目录。

```JavaScript
app.use(express.static('public'))
app.use(express.static('uploads'))
app.use(express.static('files'))
```

### 7.5 第三方中间件

安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。

下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser

```JavaScript
$ npm install cookie-parser
var express = require('express')
var app = express()
var cookieParser = require('cookie-parser')

// 加载用于解析 cookie 的中间件
app.use(cookieParser())
```

## 8.获取参数

### 8.1 req.query

req.query()可以用来获取接口请求中拼接在链接"?"后边的参数，主要用于get请求，post请求也适用。 req.query()被express原生支持，并且会自动将参数转换为对象形式返回。 请求：

```
http://localhost:5050/server?p=user&q=password
```

express接口:

```JavaScript
let express = require('express')
let server = express()
server.get('/server',(req,resp)=>{
    console.log(req.query);
    resp.send('')
})
server.listen(5050,()=>{
    console.log('服务器已就绪')
})
```

请求后得到的结果：

![image-20221103202150243](https://gitee.com/river-ice/notes/raw/master/%E5%89%8D%E7%AB%AF/nodejs/%E5%A4%A7%E4%BD%AC/assets/75af32b9b18f18c515720fea9909e2ee9e98123c.png)

### 8.2 req.params

req.params()有些特殊，它适用于在url链接上传递数据参数，需要后台接口用==:变量名==的写法发起请求。

请求：

```
http://localhost:5050/nums/1000
```

express接口：

```JavaScript
let express = require('express')
let server = express();
server.get('/nums/:num', (req, resp) => {
  console.log(req.params);
  resp.send('')
})
server.listen(5050, () =>{
	 console.log('服务器已就绪')
})
```

请求后得到的结果：

![image-20221103202245942](https://gitee.com/river-ice/notes/raw/master/%E5%89%8D%E7%AB%AF/nodejs/%E5%A4%A7%E4%BD%AC/assets/77d61a1ac0f8b8d16d34540bcf02f7bff28989c6.png)

### 8.3 req.body

req.body()被原生express所支持,可以直接使用req.body()获取post请求的表单数据。

请求:

```JavaScript
fecth('http://localhost:5050/people',{
    method: 'post',
    headers: {
        'Content-Type': 'application/json'
    },
    body:{name: 'zhangsan', age: 15}
})
```

express接口：

```JavaScript
const express = require('express');
const server = express();
//配置解析post参数的-不用下载第三方 ,内置
//解析post参数-(url-ky格式) username=kerwin&password=1234
// app.use(express.urlencoded({ extended: false }));
//解析post参数-(json字符串) {name:"",age:100}
app.use(express.json());
server.post('/people', (req, resp) => {
  console.log(req.body);
  resp.send('')
})
server.listen(5050, () => console.log('服务器已就绪'))
```

![image-20221103202743889](https://gitee.com/river-ice/notes/raw/master/%E5%89%8D%E7%AB%AF/nodejs/%E5%A4%A7%E4%BD%AC/assets/25cbb7ad14c21077add671c586e0f18f4a6c61b8.png)

## 9.利用 Express 托管静态文件

通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。

将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了。例如，假设在 public 目录放置了图片、CSS 和 JavaScript 文件，你就可以：

```JavaScript
//直接将public里的index.html当成/的网页
app.use(express.static('public'))
```

现在，public 目录下面的文件就可以访问了。

```
http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html
```

> 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。

如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件：

```JavaScript
app.use(express.static('public'))
app.use(express.static('files'))
```

访问静态资源文件时，express.static 中间件会根据目录添加的顺序查找所需的文件。

如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：

```JavaScript
app.use('/static', express.static('public'))
```

现在，你就可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。

```JavaScript
http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html
```

**总结**

```JavaScript
app.use(express.static('public'))
<link rel="stylesheet" href="/css/index.css" />
    
app.use('/static', express.static('public'))
<link rel="stylesheet" href="/static/css/index.css" />
```



## 项目问题：

### 404错误处理：

在Express项目中，路由模块化后，如果没有匹配到对应的路由，错误处理程序将无法捕获到这个错误。

为了解决这个问题，可以创建一个404错误处理程序，在所有路由之后添加：

```JavaScript

// Routers
const indexRouter = require('./routes/index');
const usersRouter = require('./routes/users');

// ...

app.use('/', indexRouter);
app.use('/users', usersRouter);

// 404 Error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});
```

当找不到对应的路由时，会触发该处理程序，并向下传递一个包含404状态码的Error对象。这样就可以在错误处理程序中对其进行处理。

然后需要编写另一个错误处理程序来处理这个错误:

```JavaScript

// Basic error handler
app.use(function(err, req, res, next) {
  // Set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // Render the error page
  res.status(err.status || 500);
  res.render('error');
});
```

该错误处理程序可以处理从下面传递上来的Error对象和其他一些未被处理的异常，最后根据情况渲染页面或返回错误信息。

需要注意的是，这两个错误处理程序必须在所有路由之后添加，否则可能会影响路由的正常匹配。





### 一个中小型的Express项目应该具备以下功能：

**1. 路由管理**

通过路由实现不同URL请求的处理和响应。可以使用express.Router对象来组织路由，将不同的路由逻辑分离到不同的文件中。

**2. 模板引擎**

使用模板引擎渲染视图，呈现动态的HTML页面。可以使用常见的模板引擎，如ejs、Pug等。

**3. 数据库操作**

在Express项目中需要与数据库进行交互，可以选择使用ORM框架，如Sequelize、TypeORM、Mongoose等。

**4. 用户认证和授权**

用户认证和授权是Web应用程序中非常重要的一部分，这部分可以使用Passport.js等认证框架来实现。

**5. 错误处理**

在出现错误时，需要给用户友好的提示，并记录错误日志以便后续排查问题。可以使用Express内置的错误处理机制或者自定义错误处理中间件。

**6. 静态文件服务**

为了提高性能和速度，静态文件通常不会被放在应用程序的根目录下，而是单独存放在一个public或static等目录下。通过express.static中间件提供静态文件服务。

**7. API接口**

如果项目需要提供API服务，可以使用restful风格设计API接口，并使用 swagger 或 postman 等工具来管理API文档和测试。

**8. 日志记录**

记录应用程序的运行日志，包括访问日志、错误日志等，可以使用morgan等日志中间件来实现。

**9. 缓存处理**

对于一些静态数据或经常使用的数据，可以使用缓存来提高页面渲染速度。可以使用Redis等缓存工具。

以上是一个中小型Express项目应该具备的功能，根据具体需求还可以添加其他功能模块。





### 缓存处理：

在Express项目中，可以通过缓存来提高应用程序的响应速度和性能。以下是一些常见的缓存处理方式：

**1. 前端缓存**

前端缓存是指将静态资源（如图片、CSS、JavaScript文件等）保存在客户端浏览器中，避免每次请求时都重新下载这些资源。可以使用ETag、Last-Modified等HTTP头信息来控制浏览器缓存，也可以使用Cache-Control、Expires等HTTP头信息来设置缓存时间。

```
javascript
// 设置静态资源的缓存时间为1天
app.use(express.static(path.join(__dirname, 'public'), { maxAge: '1d' }));
```

**2. 后端缓存**

后端缓存是指将动态生成的页面或数据缓存到服务器端，避免重复计算或查询数据库。可以使用Redis、Memcached等内存数据库来实现后端缓存。

```JavaScript
javascript
const redis = require('redis');
const client = redis.createClient();

app.get('/api/user/:id', (req, res) => {
  const userId = req.params.id;

  // 先从缓存中查找数据
  client.get(userId, (err, data) => {
    if (err) throw err;
    if (data !== null) {
      // 如果缓存中有数据，则直接返回
      res.send(JSON.parse(data));
    } else {
      // 如果缓存中没有数据，则从数据库中查询
      db.query('SELECT * FROM users WHERE id = ?', [userId], (err, result) => {
        if (err) throw err;

        // 将查询结果缓存到Redis中
        client.setex(userId, 3600, JSON.stringify(result));
        res.send(result);
      });
    }
  });
});
```

以上代码中使用Redis缓存了一个用户数据，首先从缓存中查找数据，如果有则直接返回，如果没有则从数据库中查询，并将查询结果缓存到Redis中。

需要注意的是，后端缓存需要避免缓存过期时间太长，否则可能会因为业务逻辑变化或者数据更新而导致缓存命中率下降。





### 将日志写入文件中：

[morgan](https://www.npmjs.com/package/morgan)是一个Node.js的HTTP请求记录中间件。它可以帮助我们记录来自客户端的HTTP请求，并将其输出到控制台或日志文件中。

要在Node.js中使用morgan模块，首先需要通过以下命令安装：

```
bash
npm install morgan
```

接下来，在你的代码中引入morgan模块并将其作为一个中间件添加到你的Express应用程序中。

```JavaScript
javascript
const express = require('express');
const morgan = require('morgan');

const app = express();

// 添加morgan中间件
app.use(morgan('combined'));
```

morgan支持多个预定义格式来记录HTTP请求的信息，例如：combined、common、dev等等。其中，combined格式包含了最全面的信息，包括了时间戳、HTTP方法、URL、状态码、响应大小等等。

你也可以创建自定义格式，只需传递一个回调函数给morgan即可。

```JavaScript
javascript
app.use(morgan(function (tokens, req, res) {
  return [
    tokens.method(req, res),
    tokens.url(req, res),
    tokens.status(req, res),
    tokens.res(req, res, 'content-length'), '-',
    tokens['response-time'](req, res), 'ms'
  ].join(' ')
}));
```

以上代码创建了一个自定义的日志格式，它将HTTP方法、URL、状态码、响应大小和响应时间（以毫秒为单位）记录到日志中。

无论使用哪种格式，morgan都会将日志消息输出到标准输出（控制台）上。如果需要将日志记录到文件中，可以使用[rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream)等其他模块来实现。

[morgan](https://www.npmjs.com/package/morgan)模块默认将日志消息输出到标准输出（控制台）上。如果需要将日志消息记录到文件中，可以使用[rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream)等其他模块来实现。

以下是使用`rotating-file-stream`模块和自定义格式将日志消息记录到文件的示例代码：

```JavaScript
javascript
const express = require('express');
const morgan = require('morgan');
const rfs = require('rotating-file-stream');

const app = express();

// 创建一个每天轮转的可写流
const accessLogStream = rfs.createStream('access.log', {
  interval: '1d', // 执行轮替的时间间隔
  path: './logs'  // 存储日志文件的路径
});

// 定义自定义格式
const loggerFormat = ':remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"';

// 添加morgan中间件，将日志消息记录到文件中
app.use(morgan(loggerFormat, { stream: accessLogStream }));

// ...其余代码...
```

在上述代码中，我们使用`rotating-file-stream`模块创建了一个每天轮转的可写流，并将其命名为`access.log`。这将导致日志文件以日期为后缀进行轮替，例如`access.log-20220101`、`access.log-20220102`等等。

然后，我们使用自定义格式`loggerFormat`和`accessLogStream`作为参数来调用[morgan](https://www.npmjs.com/package/morgan)中间件。这将导致日志消息被写入到文件中而不是标准输出（控制台）上。

最后，我们将`access.log`文件存储在`./logs`目录中。如果该目录不存在，则需要先创建它。

### cookie值验证：在Express中，可以通过使用[cookie-parser](https://www.npmjs.com/package/cookie-parser)模块来解析客户端传递的cookie数据。例如：

```JavaScript
javascript
const express = require('express');
const cookieParser = require('cookie-parser');

const app = express();

// 使用cookie-parser中间件解析cookie数据
app.use(cookieParser());

// 处理GET请求
app.get('/', (req, res) => {
  // 从cookies对象中获取名为token的cookie值
  const token = req.cookies.token;

  // 验证cookie值是否存在或合法
  if (!token || !isValidToken(token)) {
    // 如果验证失败，则返回401 Unauthorized响应
    return res.status(401).send('Unauthorized');
  }

  // 如果验证成功，则返回受保护的内容
  res.send('Protected content');
});

// 验证token是否合法
function isValidToken(token) {
  // TODO: 实现验证逻辑
  return true;
}

// 启动服务器
app.listen(3000, () => {
  console.log('Server started on port 3000');
});
```

在上述代码中，我们首先使用`cookie-parser`中间件将客户端传递的cookie数据解析到`req.cookies`对象中。然后，在处理GET请求时，我们从`req.cookies`对象中获取名为`token`的cookie值，并调用`isValidToken`函数对其进行验证。

如果`token`值不存在或不合法，则返回`401 Unauthorized`响应。否则，返回受保护的内容。

需要注意的是，这里的`isValidToken`函数仅是一个示例。实际上，验证cookie的逻辑可能会更加复杂，需要根据具体情况进行实现。

在Node.js中，验证cookie的逻辑通常分为以下几个步骤：

1. 从HTTP请求中获取cookie值。
2. 解密或解析cookie值。
3. 验证cookie是否过期或失效。
4. 验证cookie是否被篡改。
5. 如果cookie验证通过，则将用户信息存储在session中，或者在响应头中设置授权令牌。

下面是一个简单的例子，演示如何实现这些步骤：

```JavaScript
javascript
const jwt = require('jsonwebtoken');

// 处理GET请求
app.get('/', (req, res) => {
  try {
    // 从cookies对象中获取名为token的cookie值
    const token = req.cookies.token;

    // 验证cookie是否为空
    if (!token) {
      return res.status(401).send('Unauthorized');
    }

    // 解密或解析cookie值
    const decoded = jwt.verify(token, 'secret');
    const userId = decoded.userId;

    // 验证cookie是否过期或失效
    if (isTokenExpired(decoded)) {
      return res.status(401).send('Token expired');
    }

    // 验证cookie是否被篡改
    if (isTokenTampered(decoded)) {
      return res.status(401).send('Token tampered');
    }

    // 将用户信息存储在session中，或者在响应头中设置授权令牌
    // TODO: 实现存储逻辑

    // 返回受保护的内容
    res.send('Protected content');
  } catch (err) {
    // 如果出现异常，则返回401 Unauthorized响应
    res.status(401).send('Unauthorized');
  }
});

// 判断token是否过期
function isTokenExpired(decoded) {
  // TODO: 实现判断逻辑
  return false;
}

// 判断token是否被篡改
function isTokenTampered(decoded) {
  // TODO: 实现判断逻辑
  return false;
}
```

在上述代码中，我们使用jsonwebtoken模块解密或解析cookie值，并从中获取用户ID。然后，我们分别调用`isTokenExpired`和`isTokenTampered`函数对cookie进行验证。

如果cookie验证通过，则可以将用户信息存储在session中，或者在响应头中设置授权令牌，以便后续请求可以进行身份验证。如果cookie验证失败，则返回`401 Unauthorized`响应。

需要注意的是，这里的`isTokenExpired`和`isTokenTampered`函数仅是示例。实际上，实现这些函数需要根据具体情况进行相应的计算和比较。例如，判断cookie是否过期通常需要比较cookie中的时间戳和当前时间戳的差值。

### 指定process.env.(***参数)

在生产环境中，可以通过以下几种方式设置`process.env`环境变量：

1. 手动设置环境变量 如果您使用的是Unix/Linux操作系统，可以在`.bashrc`、`.zshrc`或者`/etc/environment`等文件中手动设置环境变量。例如，在`.bashrc`文件中添加以下代码：

```
bash
export DATABASE_URL=mongodb://localhost/myapp
```

在上述代码中，我们使用`export`命令将环境变量`DATABASE_URL`设置为`mongodb://localhost/myapp`。

1. 使用环境变量文件 在生产环境中，通常会使用一个单独的配置文件来保存所有的环境变量，并在应用程序启动时将它们导入到`process.env`中。例如，您可以创建一个名为`.env`的文件，其中包含以下内容：

```

DATABASE_URL=mongodb://localhost/myapp
```

然后，在应用程序代码中使用第三方模块（例如`dotenv`）加载这个`.env`文件，将其中的环境变量导入到`process.env`中：

```JavaScript
javascript
// app.js

require('dotenv').config();

const express = require('express');
const app = express();

// ...
```

在上述代码中，我们首先使用`require()`函数导入了第三方模块`dotenv`，然后在代码开头调用了`dotenv.config()`方法，该方法会加载`.env`文件并将其中的环境变量导入到`process.env`中。

需要注意的是，使用环境变量文件可以提高代码的可维护性和可重用性，因为它可以将所有环境变量集中在一个地方进行管理，并且可以轻松地在不同的环境中切换。但请注意，使用环境变量文件可能会增加应用程序的启动时间和内存开销。

1. 在部署过程中使用部署工具或平台 如果您使用的是云计算平台（例如AWS、Heroku、Google Cloud等），可以使用相应的部署工具或平台设置环境变量。这通常比手动设置环境变量更方便和安全，因为这些工具和平台通常具有强大的安全措施和自动化功能，可以帮助您轻松管理环境变量。
## 1.函数基本介绍

函数就是语句的封装，可以让这些代码方便地被复用。

函数具有 “一次定义，多次调用” 的优点。

使用函数，可以简化代码，让代码更具有可读性。

**函数也是一个对象，也具有普通对象的功能（能有属性）**
使用typeof检查一个函数时会返回function

和变量类似，函数必须先定义然后才能使用。

### 函数的定义方式

#### 函数声明

```javascript
function 函数名(){
语句...
}
```

#### 函数表达式

```javascript
const 变量 = function(){
语句...
}

const 变量 = () => {
语句...
}
```

#### 箭头函数

```javascript
const 变量 = () => {
语句...
}
```

箭头函数注意事项：

- 只有一个语句，箭头函数的大括号可以省略不写
- 只有一个参数，箭头函数的参数括号可省略
- 没有自己的this和arguments，不能作为构造函数调用
- 无法通过call、apply、bind指定函数的this



## 2.函数的声明提升

和变量声明提升类似，函数声明也可以被提升。

1. **变量的声明提前**
   在全局作用域中，使用**var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。**
   所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。
   在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，
   如果没有使用var关键字声明变量，则变量会变成全局变量
2. **函数的声明提前**
   在全局作用域中，使用**函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建**，
   也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性
   在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。

```JavaScript
fun();
// 在预解析阶段会被提升
function fun() {
    alert("函数被执行");
}
```

效果相当于：

```JavaScript
function fun() {
    alert("函数被执行");
}
fun();
```

【函数表达式不能被提升】

```JavaScript
fun();	// 报错！
var fun = function() {
    alert("函数不能被执行");
};
```

> 解释：函数表达式不能被提升的本质原因是函数表达式定义的其实是个变量，只不过是把函数赋给这个变量，而变量的提升只提升定义，不提升赋值！

## 3.函数优先提升

可以简单理解为：函数提升程度 > 变量提升程度。

![image-20230302165544647](../../../AppData/Roaming/Typora/typora-user-images/image-20230302165544647.png)

```JavaScript
fun(); // B

var fun = function () {
    alert('A');
};

function fun() {
    alert('B');
}

fun(); // A
```

效果相当于：

```JavaScript
function fun() {
    alert('B');
}

var fun;

fun(); // B

fun = function () {
    alert('A');
};

fun(); // A
```



## 4.函数的参数和返回值

### 4.1 函数参数

参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值。

**形参：形式参数**

- 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开
- 定义形参就相当于在函数内声明了对应的变量但是并不赋值，
- 形参会在调用时才赋值。

**实参：实际参数**

```
- 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参 
```

- 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
  如果实参的数量大于形参，多余实参将不会赋值，**如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined**



- 如果实参和形参数量相同，则对应的实参赋值给对应的形参

- 如果实参多余形参，则多余的实参不会使用

- 如果形参多余实参，则多余的形参为undefined

- 参数的类型

  - JS中不会检查参数的类型，可以传递任何类型的值作为参数

  - 定义参数时，可以为参数指定默认值

  - 默认值会在没有对应实参时生效

  - ```javascript
    const fn = (a=10, b=20, c=30) => {
          console.log("a =", a);
          console.log("b =", b);
          console.log("c =", c);
    }
    ```

`再次强调`

> “形式参数” 和 “实际参数” 是彼此独立的，除了传递值之外，互不干扰！

> 注意：JS 只有 “值传递” 没有 “引用传递”，对于复杂类型的传递，传递的不是引用，而是那个变量里面的值（引用的地址）。
>
> 引用传递：修改形参，实参也会改变。JS 中复杂类型的实参是个地址值不需要改变，也改变不了，改变的是地址所指向的堆中的复杂类型的具体值，此处具有迷惑性，要加以辨别。